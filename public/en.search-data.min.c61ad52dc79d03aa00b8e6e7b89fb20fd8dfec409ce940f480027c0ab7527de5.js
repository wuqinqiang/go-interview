'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/order-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"order-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':1,'href':'/docs/product-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"product-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':2,'href':'/docs/user-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"user-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':3,'href':'/docs/main/','title':"开篇",'section':"Docs",'content':"开篇 #  为什么会有这个项目? #  此项目的初衷是为了帮助 Go 开发人员快速上手 gRPC 项目。  算是作者学习中对一些知识点的一些总结  网上的一些教程大多到 hello world 为止，体现不出一个正常业务开发会涉及到的方方面面。  综上所术，才有了此项目。\n当然了，还有很重要的一个原因：写文档的能力。\n日常对接文档或者使用工具的时候，一定吐槽过别人的文档写的是什么。\n我关注的是 what、how，你却一个劲的 much niubi。\n虽然会吐槽他人，但是自己写文档的时候，也照样草草了事，过于真实。\n记忆中，文档似乎和一次性口罩是一个性质的物品。前者用过就丢，后者写过就封版了。\n你会不会有这样的时刻？\n在和别人讲解自己某个项目、模块、功能的时候。你滔滔不绝，可对方依然云里雾里。就像这样：\n归根结底，我觉得有四个原因（暂且不讨论听者方面的）:\n 自身对自己做的东西没有深入去了解。遵循代码和我，有一个能跑的原则。 对细节了如指掌，但是表达能力出现问题。 没有站在读者的角度，你所谓的前置知识、技能、专业名词\u0026hellip;\u0026hellip;，对方完全不知，本质上还是信息差。 内心深处不想让别人了解这个系统，毕竟你想当唯一的消防员👩‍🚒。  能把自己写过的东西、看过的项目\u0026hellip;\u0026hellip;，通过文字、嘴对嘴、视频等方式完整清晰的表达出来是一件非常重要且值得开干的事。\n如果连文档都写不清楚，还指望自己能写好 ppt？\n"});index.add({'id':4,'href':'/docs/main/wechat/','title':"微信",'section':"开篇",'content':"联系方式 #  陶冶情操的地方 #  作者微信 #  作者女朋友 #  待定中。。。。。。\n"});index.add({'id':5,'href':'/docs/main/env/','title':"环境安装",'section':"开篇",'content':"开发环境 #  Go环境 #  首先是 Go ，直接安装最新的版本就好。这个很简单，官网地址:go安装。\nProtocol buffer #  protocol buffer ，简称 protobuf。是一种与语言、平台无关 、可扩展的序列化结构数据格式。官方有一句话:\nProtocol buffers are Google\u0026rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler.  所以它的定位类似于 xml 、json，但是从性能上和效率上大幅度优于 xml、json。\n但是它也有个缺点，可读性差，毕竟是以二进制方式存储的。\n下载安装 protocol buffer 项目地址。\n如果是 linux 使用 apt 或者 apt-get\napt install -y protobuf-compiler protoc --version # 确认版本为 3+ 如果是 Mac,使用 Homebrew,\nbrew install protobuf protoc --version # 确认版本为 3+ 官方建议使用 proto3 教程中使用的 proto3 ，如果想了解 proto3 相比 proto2 的改变可以查看这里[Protocol Buffers v3.0.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.0.0)。\nGo plugins #  protobuf 核心的工具是 C++ 开发的。在官方的编译器中并不支持 Go 语言(好奇的是为啥其他主语言都支持，是个谜)。\n所以，如果我们想要在 Go 中使用 protobuf ，还需要安装能支持在 Go 中 编译 protobuf 插件，这样我们就可以把 .proto 文件生成对应的 Go 代码了。\n执行以下命令安装插件最新版本：\ngo get -u github.com/golang/protobuf/protoc-gen-go 当然你也可以指定版本号。\n$ go get google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 当然了项目中使用的 grpc,我们需要安装对应 protobuf 编译生成 grpc 代码 的插件。\ngo get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 如果有需要，更新一下 PATH，让 protoc 命令找到插件。\nexport PATH=\u0026#34;$PATH:$(go env GOPATH)/bin\u0026#34; 顺便提一嘴，可以看到这里我使用了 go install，那么 go get 和 go install 有什么区别?\ngo install=go build +把 go build 编译后生成的可执行文件放到 GOPATH/bin 目录下。  go get = git clone + go install。  很清晰了吧。\n"});index.add({'id':6,'href':'/docs/main/grpc/','title':"初识gRPC",'section':"开篇",'content':"在正式写grpc-shop之前，我们需要先花几篇文章介绍一些基础概念。 在介绍gRPC之前我们先了解下什么是RPC。\n什么是rpc? #  RPC是Remote Procedure Call的简称，中文叫远程过程调用。\n说的白话一点，可以这么理解：现在有两台服务器A和B。部署在A服务器上的应用，想调用部署在B服务器上的另一个应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来达到调用的效果。\n现在我们在A服务的一个本地方法中封装调用B的逻辑，然后只需要在本地使用这个方法，就达到了调用B的效果。\n对使用者来说，屏蔽了细节。你只需要知道调用这个方法返回的结果，而无需关注底层逻辑。\n那，从封装的那个方法角度来看，调用B之前我们需要知道什么？\n当然是一些约定啊。\n 调用的语义，也可以理解为接口规范。(比如RESTful) 网络传输协议 (比如HTTP) 数据序列化反序列化规范(比如JSON)。  有了这些约定，我就知道如何给你发数据，发什么样的数据，你返回给我的又是什么样的数据。\n从上图中可以看出，RPC是一种客户端-服务端（Client/Server）模式。\n从某种角度来看，所有本身应用程序之外的调用都可以归类为RPC。无论是微服务、第三方HTTP接口，还是读写数据库中间件Mysql、Redis。\nHTTP 和 RPC 有什么区别？ #  我之前也问个这个问题。\n首先这个问题本身不太严谨。\n HTTP只是一个通信协议，工作在OSI第七层。\n而RPC是一个完整的远程调用方案。它包含了:接口规范、传输协议、数据序列化反序列化规范。\n这样看，RPC和 HTTP的关系只可能是包含关系。为什么是可能？因为RPC传输协议那块我可以不基于HTTP呀。\n所以这个问题应该改成:基于HTTP的远程调用方案 (如:HTTP+RESTful+JSON) 和直接使用RPC远程调用方案有什么区别？\nRPC 和 gRPC 有什么关系？ #  gRPC是由 google开发的一个高性能、通用的开源RPC框架，主要面向移动应用开发且基于HTTP/2协议标准而设计，同时支持大多数流行的编程语言。\ngRPC基于 HTTP/2协议传输。而HTTP/2相比HTTP1.x:\n用于数据传输的二进制分帧 #  HTTP/2采用二进制格式传输协议，而非HTTP/1.x的文本格式。\n多路复用 #  HTTP/2支持通过同一个连接发送多个并发的请求。\n而HTTP/1.x虽然通过pipeline也能并发请求，但多个请求之间的响应依然会被阻塞。\n服务端推送 #  服务端推送是一种在客户端请求之前发送数据的机制。在HTTP/2中，服务器可以对客户端的一个请求发送多个响应。而不像HTTP/1.X一样，只能通过客户端发起request,服务端才产生对应的response。\n减少网络流量的头部压缩。 #  HTTP/2对消息头进行了压缩传输，能够节省消息头占用的网络流量。至于如何压缩的，可以查看这篇：HPACK: Header Compression for HTTP/2\n同时gRPC使用Protocol Buffers作为序列化协议。关于Protocol Buffers。官网有一句介绍：\n Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler.\n 它是一种与语言、平台无关 、可扩展的序列化结构数据。它的定位类似于JSON、XML，但是比他们更小、更快、更简单。更多关于Protocol Buffers介绍，我下一篇再写。\ngRPC 是如何进行远程调用的? #  官网有一张图:\n从上图和文档中可以看出，用gRPC来进行远程调用服务，客户端(client) 仅仅需要gRPC Stub(为啥叫存根?) ，通过Proto Request向gRPC Server发起服务调用，然后 gRPC Server通过Proto Response(s)将调用结果返回给调用的client。\n至于上面这段逻辑gRPC里面做了啥，有哪些调用方式，介绍完pb再写。\n总结 #  第一篇文章主要介绍了RPC是什么以及一些grpc的基础概念。\n参考 #   https://grpc.io/docs/what-is-grpc/introduction/ https://httpwg.org/specs/rfc7541.html https://www.upyun.com/tech/article/227/1.html?utm_source=zhihu\u0026amp;utm_medium=referral\u0026amp;utm_campaign=202831825\u0026amp;utm_term=http2 https://www.zhihu.com/question/34074946  "});index.add({'id':7,'href':'/docs/product-srv/%E5%AE%A2%E6%88%B7%E7%AB%AF/','title':"客户端",'section':"product-srv",'content':"client #  服务端实现\nExample #  "});index.add({'id':8,'href':'/docs/product-srv/%E6%9C%8D%E5%8A%A1%E7%AB%AF/','title':"服务端",'section':"product-srv",'content':"server #  服务端实现\nExample #  "});index.add({'id':9,'href':'/docs/main/protobuf/','title':"初识 protobuf",'section':"开篇",'content':"初始protobuf #  Protobuf 是什么 #  protobuf全称是protocal buffers ，平时我们都会简称为pb，下文就使用pb来介绍了。\n官网中对pb的完整定义如下:\n Protocol buffers are Google\u0026rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.\n 简单的说， pb是一种与语言、平台无关，可扩展的序列化数据格式。它的定位类似于JSON、XML，但是比他们更小、更快、更简单。\n对于开发者来说，我们只需要定义proto文件。然后使用对应的IDL编译器把.proto文件编译成对应语言的代码即可。\n从某个角度来看，.proto文件就是接口。里面包含了接口方法、入参、出参。\n环境 #  pb #  下载安装pb 项目地址。\n如果是linux使用apt或者apt-get\napt install -y protobuf-compiler protoc --version # 确认版本为 3+ 如果是Mac,使用Homebrew`,\nbrew install protobuf protoc --version # 确认版本为 3+ 官方建议使用proto3教程中使用的proto3 ，如果想了解 proto3相比proto2的改变可以查看这里[Protocol Buffers v3.0.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.0.0)。\nGo plugins #  protobuf核心的工具是C++开发的。在官方的编译器中并不支持Go语言(好奇的是为啥其他主语言都支持，是个谜)。\n所以，如果我们想要在 Go中使用protobuf ，还需要安装能支持在Go中编译protobuf插件，这样我们就可以 .proto文件生成对应的Go代码了。\n执行以下命令安装插件最新版本：\ngo get -u github.com/golang/protobuf/protoc-gen-go 你也可以指定版本号。\n$ go get google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 当然了项目中使用的 grpc,我们需要安装对应 protobuf编译生成grpc代码的插件。\ngo get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 如果有需要，更新一下PATH，让protoc命令找到插件。\nexport PATH=\u0026#34;$PATH:$(go env GOPATH)/bin\u0026#34; 顺便提一嘴，可以看到这里我使用了go install，那么go get和go install有什么区别?\ngo install=go build +把 go build 编译后生成的可执行文件放到 GOPATH/bin 目录下。  go get = git clone + go install。  如何使用 #  我们先来看一个简单的示例，我们创建一个order.proto文件，内容如下:\nsyntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;.;order\u0026#34;; message Order { string order_id = 1; string user_id = 2; uint32 order_amount = 3; bool is_cancel = 4; } 逐行解释。\npb有两个版本，默认版本是proto2，如果要使用proto3，我们就得在非空非注释的第一行代码中使用syntax = \u0026quot;proto3\u0026quot;; 声明版本。\noption表示可选项配置。有些选项是文件级别的，需要在一个文件的顶级作用域定义，比如上面的option go_package = \u0026quot;order\u0026quot;;。\ngo_package选项，定义的值，就是把pb文件编译生成Go代码后文件的package名。这样其他生成的Go代码就可以通过关键字import使用到这个包。\n你可能还会在.proto文件中看到类似 package xxx这样的， 比如，\nsyntax = \u0026quot;proto3\u0026quot;; package order; option go_package = \u0026quot;.;order\u0026quot;; package主要用来解决不同的pb文件存在相同消息类型名称之间的冲突。比如a.proto有一个Common message，b.proto 也有一个 Common message，此时需要通过package来做区分。\n那package和go_package 有什么关系吗？\n There is no correlation between the Go import path and the package specifier in the .proto file. The latter is only relevant to the protobuf namespace, while the former is only relevant to the Go namespace. Also, there is no correlation between the Go import path and the .proto import path.\n 没有关系。\npackage只和pb空间有关，而 go_package 前面解释过了，和Go的import包有关，他们两者，本质上不是一个层面的。\n接着我们定义了一个Order的消息message类型，定义消息类型是使用关键字message 定义的。\nOrder定义了四个字段，对应string、uint32以及bool字段类型。\n消息类型中字段定义的格式为，\n[ \u0026#34;singular|repeated｜......\u0026#34; ] type fieldName \u0026#34;=\u0026#34; fieldNumber [ \u0026#34;[\u0026#34; fieldOptions \u0026#34;]\u0026#34; ] \u0026#34;;\u0026#34;默认情况下，每个字段最前面的修饰符为singular，一般省略不写。\n假设一个主订单下有多个子订单，我们可以如何定义？\nsyntax = \u0026quot;proto3\u0026quot;; option go_package = \u0026quot;.;order\u0026quot;; message Order { string order_id = 1; string user_id = 2; uint32 order_amount = 3; bool is_cancel = 4; repeated OrderItem items = 5; } message OrderItem { string title = 1; string image = 2; } 我们新定义了一个OrderItem子订单的消息类型。然后在Order中，我们使用了OrderItem作为items字段的类型值。\nrepeated是另一种修饰符，表示允许字段重复。上面的场景即一个订单有多个子订单的概念。\n编译成Go代码，items会变成slice类型。\n其他类型就不一一介绍，更多的类型可以查看这：message type\n接着我们通过命令编译(确保工具已装)生成Go相关的代码，执行如下命令：\nprotoc --proto_path=. --go_out=. *.proto --proto_path指定要编译的源码的搜索路径，上面的.表示当前目录。如果不指定--proto_path的话,默认为pwd。所以上面我们也可以省略成这样，\nprotoc --go_out=. *.proto --go_out 参数告知protoc编译器去加载对应的protoc-gen-go工具且指定编译生成Go代码后保存位置。当然如果是生成php代码那就是--php_out。对应的语言，对应--xx_out。\n最后的*.proto表示搜索当前目录下所有.proto文件。\n那么整句命令行意思就是：编译当前目录下所有.proto文件， 把生成的Go代码存放到当前目录。\n上面的命令执行后，当前目录下多了一个order.pb.go文件。生成的数据结构:\n// 主订单 type Order struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields OrderId string `protobuf:\u0026#34;bytes,1,opt,name=order_id,json=orderId,proto3\u0026#34; json:\u0026#34;order_id,omitempty\u0026#34;` UserId string `protobuf:\u0026#34;bytes,2,opt,name=user_id,json=userId,proto3\u0026#34; json:\u0026#34;user_id,omitempty\u0026#34;` OrderAmount uint32 `protobuf:\u0026#34;varint,4,opt,name=order_amount,json=orderAmount,proto3\u0026#34; json:\u0026#34;order_amount,omitempty\u0026#34;` IsCancel bool `protobuf:\u0026#34;varint,5,opt,name=is_cancel,json=isCancel,proto3\u0026#34; json:\u0026#34;is_cancel,omitempty\u0026#34;` Items []*OrderItem `protobuf:\u0026#34;bytes,6,rep,name=items,proto3\u0026#34; json:\u0026#34;items,omitempty\u0026#34;` } ........ func (x *Order) GetOrderId() string { if x != nil { return x.OrderId } return \u0026#34;\u0026#34; } func (x *Order) GetUserId() string { if x != nil { return x.UserId } return \u0026#34;\u0026#34; } func (x *Order) GetOrderAmount() uint32 { if x != nil { return x.OrderAmount } return 0 } ...... // 子订单 type OrderItem struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Title string `protobuf:\u0026#34;bytes,1,opt,name=title,proto3\u0026#34; json:\u0026#34;title,omitempty\u0026#34;` Image string `protobuf:\u0026#34;bytes,2,opt,name=image,proto3\u0026#34; json:\u0026#34;image,omitempty\u0026#34;` } ...... 可以看到生成的主订单结构中，Items 是一个切片类型。同时生成的还有一些Getxxx方法，方便读取字段值。\n等等，接口呢？\nmessage 有了，现在我们可以在.proto文件定义RPC服务接口了。\nsyntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;.;order\u0026#34;; service OrderService { rpc GetOrderList (OrderListReq) returns (OrderListResp) {} } message OrderListReq { string user_id = 1; } message OrderListResp { repeated Order list = 1; } message Order { string order_id = 1; string user_id = 2; uint32 order_amount = 3; bool is_cancel = 4; repeated OrderItem items = 5; } message OrderItem { string title = 1; string image = 2; } 我们定义了一个 OrderService 的服务，提供了一个GetOrderList的接口，它的入参是OrderListReq，返回类型是OrderListResp，是不是很像我们平常定义的函数。\n和平常自定义函数的不同在于，可以自定义无入参出参的函数，而在pb中接口必须携带参数，否则编译的时候会报，\nExpected type name 针对不需要参数的情况，我们一般会定义一个空message类型或者传入google.protobuf.Empty，传入google.protobuf.Empty 不好点在于不易扩展，万一这个接口要参数了呢。\nservice定义完毕，再次执行上述命令，你会发现，重新生成的order.pb.go文件并没有变化。这是因为RPC框架很多，protoc编译器并不知道给我们生成哪个RPC框架的代码。\nprotoc-gen-go内部已经集成了一个名为gRPC的插件，所以我们可以通过命令行参数--go-grpc_out生成gRPC代码：\nprotoc --go_out=. --go-grpc_out=. *.proto 然后你就发现这个错误，\n我们需要改动 option go_package = \u0026quot;.;order\u0026quot; 为 option go_package = \u0026quot;./;order\u0026quot;。\n再次执行，多出了一个order_grpc.pb.go文件。里面就能看到grpc客户端和服务端的api服务。\n// OrderServiceClient is the client API for OrderService service. type OrderServiceClient interface { GetOrderList(ctx context.Context, in *OrderListReq, opts ...grpc.CallOption) (*OrderListResp, error) } func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient { return \u0026amp;orderServiceClient{cc} } func (c *orderServiceClient) GetOrderList(ctx context.Context, in *OrderListReq, opts ...grpc.CallOption) (*OrderListResp, error) { out := new(OrderListResp) err := c.cc.Invoke(ctx, \u0026#34;/OrderService/GetOrderList\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } ...... // OrderServiceServer is the server API for OrderService service. type OrderServiceServer interface { GetOrderList(context.Context, *OrderListReq) (*OrderListResp, error) mustEmbedUnimplementedOrderServiceServer() } func RegisterOrderServiceServer(s grpc.ServiceRegistrar, srv OrderServiceServer) { s.RegisterService(\u0026amp;OrderService_ServiceDesc, srv) } 总结 #  这篇主要介绍了pb一些基础的知识，包括定义message、service以及通过protoc-gen-go生成对应的Go代码，gRPC代码。关于 protoc命令，后面有必要再单独写一篇文章。\n下一篇，通过生成的Go代码，完成gRPC通信，然后正式步入主题。\n参考 #   https://grpc.io/docs/languages/go/quickstart/ https://developers.google.com/protocol-buffers https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/#option https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-02-pb-intro.html  "});index.add({'id':10,'href':'/docs/product-srv/%E4%B8%AD%E9%97%B4%E4%BB%B6/','title':"中间件",'section':"product-srv",'content':"中间件 #  待填\nExample #  "});index.add({'id':11,'href':'/docs/main/%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/','title':"初始化项目",'section':"开篇",'content':"初始化项目 #  "});index.add({'id':12,'href':'/docs/product-srv/%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/','title':"数据验证",'section':"product-srv",'content':"数据验证 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':13,'href':'/docs/product-srv/tls%E8%AE%A4%E8%AF%81/','title':"tls认证",'section':"product-srv",'content':"中间件 #  待填\nExample #  "});index.add({'id':14,'href':'/docs/product-srv/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/','title':"超时控制",'section':"product-srv",'content':"超时控制 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':15,'href':'/docs/product-srv/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/','title':"服务发现",'section':"product-srv",'content':"服务发现 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':16,'href':'/docs/product-srv/%E5%85%A8%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/','title':"全链路追踪",'section':"product-srv",'content':"全链路追踪 #  待填\nExample #  "});index.add({'id':17,'href':'/docs/product-srv/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/','title':"负载均衡",'section':"product-srv",'content':"负载均衡 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});})();