'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/order-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"order-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':1,'href':'/docs/product-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"product-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':2,'href':'/docs/user-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"user-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':3,'href':'/docs/main/','title':"开篇",'section':"Docs",'content':"开篇 #  为什么会有这个项目? #  此项目的初衷是为了帮助 Go 开发人员快速上手 gRPC 项目。  算是作者学习中对一些知识点的一些总结  网上的一些教程大多到 hello world 为止，体现不出一个正常业务开发会涉及到的方方面面。  综上所术，才有了此项目。\n当然了，还有很重要的一个原因：写文档的能力。\n日常对接文档或者使用工具的时候，一定吐槽过别人的文档写的是什么。\n我关注的是 what、how，你却一个劲的 much niubi。\n虽然会吐槽他人，但是自己写文档的时候，也照样草草了事，过于真实。\n记忆中，文档似乎和一次性口罩是一个性质的物品。前者用过就丢，后者写过就封版了。\n你会不会有这样的时刻？\n在和别人讲解自己某个项目、模块、功能的时候。你滔滔不绝，可对方依然云里雾里。就像这样：\n归根结底，我觉得有四个原因（暂且不讨论听者方面的）:\n 自身对自己做的东西没有深入去了解。遵循代码和我，有一个能跑的原则。 对细节了如指掌，但是表达能力出现问题。 没有站在读者的角度，你所谓的前置知识、技能、专业名词\u0026hellip;\u0026hellip;，对方完全不知，本质上还是信息差。 内心深处不想让别人了解这个系统，毕竟你想当唯一的消防员👩‍🚒。  能把自己写过的东西、看过的项目\u0026hellip;\u0026hellip;，通过文字、嘴对嘴、视频等方式完整清晰的表达出来是一件非常重要且值得开干的事。\n如果连文档都写不清楚，还指望自己能写好 ppt？\n"});index.add({'id':4,'href':'/docs/main/wechat/','title':"微信",'section':"开篇",'content':"联系方式 #  陶冶情操的地方 #  作者微信 #  作者女朋友 #  待定中。。。。。。\n"});index.add({'id':5,'href':'/docs/main/env/','title':"环境安装",'section':"开篇",'content':"开发环境 #  Go环境 #  首先是 Go ，直接安装最新的版本就好。这个很简单，官网地址:go安装。\nProtocol buffer #  protocol buffer ，简称 protobuf。是一种与语言、平台无关 、可扩展的序列化结构数据格式。官方有一句话:\nProtocol buffers are Google\u0026rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler.  所以它的定位类似于 xml 、json，但是从性能上和效率上大幅度优于 xml、json。\n但是它也有个缺点，可读性差，毕竟是以二进制方式存储的。\n下载安装 protocol buffer 项目地址。\n如果是 linux 使用 apt 或者 apt-get\napt install -y protobuf-compiler protoc --version # 确认版本为 3+ 如果是 Mac,使用 Homebrew,\nbrew install protobuf protoc --version # 确认版本为 3+ 官方建议使用 proto3 教程中使用的 proto3 ，如果想了解 proto3 相比 proto2 的改变可以查看这里[Protocol Buffers v3.0.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.0.0)。\nGo plugins #  protobuf 核心的工具是 C++ 开发的。在官方的编译器中并不支持 Go 语言(好奇的是为啥其他主语言都支持，是个谜)。\n所以，如果我们想要在 Go 中使用 protobuf ，还需要安装能支持在 Go 中 编译 protobuf 插件，这样我们就可以把 .proto 文件生成对应的 Go 代码了。\n执行以下命令安装插件最新版本：\ngo get -u github.com/golang/protobuf/protoc-gen-go 当然你也可以指定版本号。\n$ go get google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 当然了项目中使用的 grpc,我们需要安装对应 protobuf 编译生成 grpc 代码 的插件。\ngo get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 如果有需要，更新一下 PATH，让 protoc 命令找到插件。\nexport PATH=\u0026#34;$PATH:$(go env GOPATH)/bin\u0026#34; 顺便提一嘴，可以看到这里我使用了 go install，那么 go get 和 go install 有什么区别?\ngo install=go build +把 go build 编译后生成的可执行文件放到 GOPATH/bin 目录下。  go get = git clone + go install。  很清晰了吧。\n"});index.add({'id':6,'href':'/docs/main/grpc/','title':"初识gRPC",'section':"开篇",'content':"初始gRPC #  在聊 gRPC 之前我们先来了解下什么是 rpc。\n什么是rpc? #  RPC 是 Remote Procedure Call 的简称，中文我们一般叫做远程过程调用。RPC 是一种服务器-客户端（Client/Server）模式，经典实现就是一个通过发送请求-接受回应进行信息交互的系统。\nRPC 的客户端和服务端可以在一台机器上，也可以在不同的机器上，对于开发者来说，调用 RPC 服务的时候，就跟调用本地函数一样。对于开发者来说。\nhttp 和 rpc 有什么区别？ #  首先这个问题本身不太严谨。\n http 只是一个工作在应用层的传输协议。\n而 RPC 是一个完整的远程调用方案。\n它包含了:\n 接口规范 数据序列化规范 传输协议  这样看，RPC 和 http 的关系只可能是包含关系。为什么是可能？因为 RPC 传输协议那块我可以不基于 http 呀。\n这个问题应该改成:基于 http 的远程调用方案 (如:http +RestFul(接口规范)+json(数据序列化规范)) 和直接使用 rpc 远程调用方案有什么区别？\nRPC 和 gRPC 有什么关系？ #  gRPC 是由 google 发起的一个 RPC 框架，基于 HTTP/2 协议传输。使用 Protocol Buffers 作为序列化协议。关于 Protocol Buffers 是一种与语言、平台无关 、可扩展的序列化结构数据格式。类似 JSON、XML等数据描述语言。更多关于 Protocol Buffers,我写了另一篇文章。\nRPC 是如何进行远程调用的? #  官网有一张图:\n用 gRPC 来进行远程调用客户端(client) 仅仅需要 gRPC Stub (为啥叫存根啊？) 通过 Proto Request 向 gRPC Server 发起服务调用即可，然后 gRPC Server 通过 Proto Response(s) 将调用结果返回给 client。\n更具体的说明可以查看文档。\n"});index.add({'id':7,'href':'/docs/product-srv/%E5%AE%A2%E6%88%B7%E7%AB%AF/','title':"客户端",'section':"product-srv",'content':"client #  服务端实现\nExample #  "});index.add({'id':8,'href':'/docs/product-srv/%E6%9C%8D%E5%8A%A1%E7%AB%AF/','title':"服务端",'section':"product-srv",'content':"server #  服务端实现\nExample #  "});index.add({'id':9,'href':'/docs/main/protobuf/','title':"初识 protobuf",'section':"开篇",'content':"初始gRPC #  "});index.add({'id':10,'href':'/docs/product-srv/%E4%B8%AD%E9%97%B4%E4%BB%B6/','title':"中间件",'section':"product-srv",'content':"中间件 #  待填\nExample #  "});index.add({'id':11,'href':'/docs/main/%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/','title':"初始化项目",'section':"开篇",'content':"初始化项目 #  "});index.add({'id':12,'href':'/docs/product-srv/%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/','title':"数据验证",'section':"product-srv",'content':"数据验证 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':13,'href':'/docs/product-srv/tls%E8%AE%A4%E8%AF%81/','title':"tls认证",'section':"product-srv",'content':"中间件 #  待填\nExample #  "});index.add({'id':14,'href':'/docs/product-srv/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/','title':"超时控制",'section':"product-srv",'content':"超时控制 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':15,'href':'/docs/product-srv/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/','title':"服务发现",'section':"product-srv",'content':"服务发现 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':16,'href':'/docs/product-srv/%E5%85%A8%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/','title':"全链路追踪",'section':"product-srv",'content':"全链路追踪 #  待填\nExample #  "});index.add({'id':17,'href':'/docs/product-srv/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/','title':"负载均衡",'section':"product-srv",'content':"负载均衡 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});})();