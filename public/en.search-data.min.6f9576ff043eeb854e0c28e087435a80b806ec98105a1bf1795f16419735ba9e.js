'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/order-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"order-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':1,'href':'/docs/product-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"product-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':2,'href':'/docs/user-srv/pb%E6%96%87%E4%BB%B6/','title':"pb文件",'section':"user-srv",'content':"pb #  下面让我们来编写商品的pb文件。\nExample #  "});index.add({'id':3,'href':'/docs/main/','title':"开篇",'section':"Docs",'content':"开篇 #  为什么会有这个项目? #  此项目的初衷是为了帮助 Go 开发人员快速上手 gRPC 项目。  算是作者学习中对一些知识点的一些总结  网上的一些教程大多到 hello world 为止，体现不出一个正常业务开发会涉及到的方方面面。  综上所术，才有了此项目。\n当然了，还有很重要的一个原因：写文档的能力。\n日常对接文档或者使用工具的时候，一定吐槽过别人的文档写的是什么。\n我关注的是 what、how，你却一个劲的 much niubi。\n虽然会吐槽他人，但是自己写文档的时候，也照样草草了事，过于真实。\n记忆中，文档似乎和一次性口罩是一个性质的物品。前者用过就丢，后者写过就封版了。\n你会不会有这样的时刻？\n在和别人讲解自己某个项目、模块、功能的时候。你滔滔不绝，可对方依然云里雾里。就像这样：\n归根结底，我觉得有四个原因（暂且不讨论听者方面的）:\n 自身对自己做的东西没有深入去了解。遵循代码和我，有一个能跑的原则。 对细节了如指掌，但是表达能力出现问题。 没有站在读者的角度，你所谓的前置知识、技能、专业名词\u0026hellip;\u0026hellip;，对方完全不知，本质上还是信息差。 内心深处不想让别人了解这个系统，毕竟你想当唯一的消防员👩‍🚒。  能把自己写过的东西、看过的项目\u0026hellip;\u0026hellip;，通过文字、嘴对嘴、视频等方式完整清晰的表达出来是一件非常重要且值得开干的事。\n如果连文档都写不清楚，还指望自己能写好 ppt？\n"});index.add({'id':4,'href':'/docs/main/wechat/','title':"微信",'section':"开篇",'content':"联系方式 #  陶冶情操的地方 #  作者微信 #  作者女朋友 #  待定中。。。。。。\n"});index.add({'id':5,'href':'/docs/main/env/','title':"环境安装",'section':"开篇",'content':"开发环境 #  Go环境 #  首先是 Go ，直接安装最新的版本就好。这个很简单，官网地址:go安装。\nProtocol buffer #  protocol buffer ，简称 protobuf。是一种与语言、平台无关 、可扩展的序列化结构数据格式。官方有一句话:\nProtocol buffers are Google\u0026rsquo;s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler.  所以它的定位类似于 xml 、json，但是从性能上和效率上大幅度优于 xml、json。\n但是它也有个缺点，可读性差，毕竟是以二进制方式存储的。\n下载安装 protocol buffer 项目地址。\n如果是 linux 使用 apt 或者 apt-get\napt install -y protobuf-compiler protoc --version # 确认版本为 3+ 如果是 Mac,使用 Homebrew,\nbrew install protobuf protoc --version # 确认版本为 3+ 官方建议使用 proto3 教程中使用的 proto3 ，如果想了解 proto3 相比 proto2 的改变可以查看这里[Protocol Buffers v3.0.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.0.0)。\nGo plugins #  protobuf 核心的工具是 C++ 开发的。在官方的编译器中并不支持 Go 语言(好奇的是为啥其他主语言都支持，是个谜)。\n所以，如果我们想要在 Go 中使用 protobuf ，还需要安装能支持在 Go 中 编译 protobuf 插件，这样我们就可以把 .proto 文件生成对应的 Go 代码了。\n执行以下命令安装插件最新版本：\ngo get -u github.com/golang/protobuf/protoc-gen-go 当然你也可以指定版本号。\n$ go get google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 当然了项目中使用的 grpc,我们需要安装对应 protobuf 编译生成 grpc 代码 的插件。\ngo get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 如果有需要，更新一下 PATH，让 protoc 命令找到插件。\nexport PATH=\u0026#34;$PATH:$(go env GOPATH)/bin\u0026#34; 顺便提一嘴，可以看到这里我使用了 go install，那么 go get 和 go install 有什么区别?\ngo install=go build +把 go build 编译后生成的可执行文件放到 GOPATH/bin 目录下。  go get = git clone + go install。  很清晰了吧。\n"});index.add({'id':6,'href':'/docs/main/grpc/','title':"初识gRPC",'section':"开篇",'content':"在正式写grpc-shop之前，我们需要先花几篇文章介绍一些基础概念。 在介绍gRPC之前我们先了解下什么是RPC。\n什么是rpc? #  RPC是Remote Procedure Call的简称，中文叫远程过程调用。\n说的白话一点，可以这么理解：现在有两台服务器A和B。部署在A服务器上的应用，想调用部署在B服务器上的另一个应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来达到调用的效果。\n现在我们在A服务的一个本地方法中封装调用B的逻辑，然后只需要在本地使用这个方法，就达到了调用B的效果。\n对使用者来说，屏蔽了细节。你只需要知道调用这个方法返回的结果，而无需关注底层逻辑。\n那，从封装的那个方法角度来看，调用B之前我们需要知道什么？\n当然是一些约定啊。\n 调用的语义，也可以理解为接口规范。(比如RESTful) 网络传输协议 (比如HTTP) 数据序列化反序列化规范(比如JSON)。  有了这些约定，我就知道如何给你发数据，发什么样的数据，你返回给我的又是什么样的数据。\n从上图中可以看出，RPC是一种客户端-服务端（Client/Server）模式。\n从某种角度来看，所有本身应用程序之外的调用都可以归类为RPC。无论是微服务、第三方HTTP接口，还是读写数据库中间件Mysql、Redis。\nHTTP 和 RPC 有什么区别？ #  我之前也问个这个问题。\n首先这个问题本身不太严谨。\n HTTP只是一个通信协议，工作在OSI第七层。\n而RPC是一个完整的远程调用方案。它包含了:接口规范、传输协议、数据序列化反序列化规范。\n这样看，RPC和 HTTP的关系只可能是包含关系。为什么是可能？因为RPC传输协议那块我可以不基于HTTP呀。\n所以这个问题应该改成:基于HTTP的远程调用方案 (如:HTTP+RESTful+JSON) 和直接使用RPC远程调用方案有什么区别？\nRPC 和 gRPC 有什么关系？ #  gRPC是由 google开发的一个高性能、通用的开源RPC框架，主要面向移动应用开发且基于HTTP/2协议标准而设计，同时支持大多数流行的编程语言。\ngRPC基于 HTTP/2协议传输。而HTTP/2相比HTTP1.x:\n用于数据传输的二进制分帧 #  HTTP/2采用二进制格式传输协议，而非HTTP/1.x的文本格式。\n多路复用 #  HTTP/2支持通过同一个连接发送多个并发的请求。\n而HTTP/1.x虽然通过pipeline也能并发请求，但多个请求之间的响应依然会被阻塞。\n服务端推送 #  服务端推送是一种在客户端请求之前发送数据的机制。在HTTP/2中，服务器可以对客户端的一个请求发送多个响应。而不像HTTP/1.X一样，只能通过客户端发起request,服务端才产生对应的response。\n减少网络流量的头部压缩。 #  HTTP/2对消息头进行了压缩传输，能够节省消息头占用的网络流量。至于如何压缩的，可以查看这篇：HPACK: Header Compression for HTTP/2\n同时gRPC使用Protocol Buffers作为序列化协议。关于Protocol Buffers。官网有一句介绍：\n Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler.\n 它是一种与语言、平台无关 、可扩展的序列化结构数据。它的定位类似于JSON、XML，但是比他们更小、更快、更简单。更多关于Protocol Buffers介绍，我下一篇再写。\ngRPC 是如何进行远程调用的? #  官网有一张图:\n从上图和文档中可以看出，用gRPC来进行远程调用服务，客户端(client) 仅仅需要gRPC Stub(为啥叫存根?) ，通过Proto Request向gRPC Server发起服务调用，然后 gRPC Server通过Proto Response(s)将调用结果返回给调用的client。\n至于上面这段逻辑gRPC里面做了啥，有哪些调用方式，介绍完pb再写。\n总结 #  第一篇文章主要介绍了RPC是什么以及一些grpc的基础概念。\n参考 #   https://grpc.io/docs/what-is-grpc/introduction/ https://httpwg.org/specs/rfc7541.html https://www.upyun.com/tech/article/227/1.html?utm_source=zhihu\u0026amp;utm_medium=referral\u0026amp;utm_campaign=202831825\u0026amp;utm_term=http2 https://www.zhihu.com/question/34074946  "});index.add({'id':7,'href':'/docs/product-srv/%E5%AE%A2%E6%88%B7%E7%AB%AF/','title':"客户端",'section':"product-srv",'content':"client #  服务端实现\nExample #  "});index.add({'id':8,'href':'/docs/product-srv/%E6%9C%8D%E5%8A%A1%E7%AB%AF/','title':"服务端",'section':"product-srv",'content':"server #  服务端实现\nExample #  "});index.add({'id':9,'href':'/docs/main/protobuf/','title':"初识 protobuf",'section':"开篇",'content':"初始gRPC #  "});index.add({'id':10,'href':'/docs/product-srv/%E4%B8%AD%E9%97%B4%E4%BB%B6/','title':"中间件",'section':"product-srv",'content':"中间件 #  待填\nExample #  "});index.add({'id':11,'href':'/docs/main/%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/','title':"初始化项目",'section':"开篇",'content':"初始化项目 #  "});index.add({'id':12,'href':'/docs/product-srv/%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/','title':"数据验证",'section':"product-srv",'content':"数据验证 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':13,'href':'/docs/product-srv/tls%E8%AE%A4%E8%AF%81/','title':"tls认证",'section':"product-srv",'content':"中间件 #  待填\nExample #  "});index.add({'id':14,'href':'/docs/product-srv/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/','title':"超时控制",'section':"product-srv",'content':"超时控制 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':15,'href':'/docs/product-srv/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/','title':"服务发现",'section':"product-srv",'content':"服务发现 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});index.add({'id':16,'href':'/docs/product-srv/%E5%85%A8%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/','title':"全链路追踪",'section':"product-srv",'content':"全链路追踪 #  待填\nExample #  "});index.add({'id':17,'href':'/docs/product-srv/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/','title':"负载均衡",'section':"product-srv",'content':"负载均衡 #  之前我们实现了服务代码，但是你可以看到，并没有对参数进行验证。\nExample #  "});})();